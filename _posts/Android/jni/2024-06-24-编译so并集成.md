---
layout: post
title: Android 编译、集成 so
date: 2024-06-24 16:19:00 +0800
category: Android
thumbnail: ../../assets/images/android-jni.jpg
icon: code
---

* content
{:toc}

#### 1、定义 native 接口

~~~java
package com.jinyx;

public class Test {
    public native String getContentFromJni(String param);
}
~~~

#### 2、生成 .h 头文件

~~~shell
# 编译生成 com/jinyx/Test.class 字节码文件
javac com/jinyx/Test.java
# 生成 com_jinyx_Test.h 头文件
javah com.jinyx.Test
# 上面两句可以合并成一句
javac -h ./ com/jinyx/Test.java
~~~

&emsp;生成的头文件内容如下:

~~~h
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_jinyx_Test */

#ifndef _Included_com_jinyx_Test
#define _Included_com_jinyx_Test
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_jinyx_Test
 * Method:    getContentFromJni
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_jinyx_Test_getContentFromJni
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif

~~~

#### 3、根据 com_jinyx_Test.h 编写 c 

~~~c
#include <stdio.h>
#include <android/log.h>
#include "com_jinyx_Test.h"

JNIEXPORT jstring JNICALL Java_com_jinyx_Test_getContentFromJni
(JNIEnv *env, jobject jobj, jstring jparam) {
    char *in = (char *) (*env)->GetStringUTFChars(env, jparam, NULL);
    __android_log_print(ANDROID_LOG_DEBUG, "jni_tag", "%s\n", in);
    return (*env)->NewStringUTF(env, "hello Android - Jni");
}
~~~

#### 4、编写 Android.mk 和 Application.mk

- **Android.mk**

~~~mk
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := test
LOCAL_SRC_FILES := test.c
# error: undefined reference to '__android_log_print'  需要添加如下 log 链接库
LOCAL_LDLIBS := -llog
include $(BUILD_SHARED_LIBRARY)
~~~

- **Application.mk**

~~~mk
APP_ABI := armeabi-v7a,arm64-v8a
~~~

#### 5、ndk 编译生成 so 动态库

~~~shell
/path/to/ndk-build NDK_PROJECT_PATH=./ NDK_APPLICATION_MK=./Application.mk APP_BUILD_SCRIPT=./Android.mk
~~~

&emsp;编译成功后在 `NDK_PROJECT_PATH` 指定目录下的 libs 目录中生成对应 `Application.mk` 中指定的平台 so。

~~~
└── libs
    ├── arm64-v8a
    │   └── libtest.so
    └── armeabi-v7a
        └── libtest.so
~~~

#### 6、android 集成

&emsp;将生成的 so 放在应用模块的 `src/main/jniLibs` 目录下，并在应用模块的 `build.gradle` 中添加平台架构限制

~~~
└── jniLibs
    ├── arm64-v8a
    │   └── libtest.so
    └── armeabi-v7a
        └── libtest.so
~~~

~~~groovy
defaultConfig {
    // ...
    ndk {
        abiFilters "armeabi-v7a", "arm64-v8a"
    }
}
~~~

#### 7、编写 native 层调用代码

~~~java
package com.jinyx;

public class Test {

    static {
        System.loadLibrary("test");
    }

    private static Test instance;

    private native String getContentFromJni(String param);

    public static Test getInstance() {
        if (instance == null) {
            synchronized (Test.class) {
                if (instance == null) {
                    instance = new Test();
                }
            }
        }
        return instance;
    }

    private Test() {

    }

    public String testJni(String param) {
        return getContentFromJni(param);
    }

}
~~~

&emsp;注意 native 方法所在文件的包名（com.jinyx）类名（Test）方法签名（返回值、方法名、参数）必须与定义的完全一致；并且在调用 native 方法前有通过 System.loadLibrary("test") 加载 so 动态库；动态库名称 libtest.so 的前 `lib` 和 后 `.so` 省略。

#### 8、调用验证

~~~java
public class TestActivity extends AppCompatActivity {

    private TextView txtContent;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);

        txtContent = findViewById(R.id.txtContent);
        txtContent.setText(Test.getInstance().testJni("Hello Jni!!!"));
    }
}
~~~

&emsp;在 Activity 中调用 native 方法并显示返回值，验证后发现 android logcat 会打印出 jni 中使用 `__android_log_print` 打印的 tag(`jni_tag`)，以及显示的文本为 jni 中的返回值内容。

